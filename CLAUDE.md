# CLAUDE.md

本文件为 Claude Code (claude.ai/code) 在此仓库中工作时提供指导。

## 项目概述

SYNTON-DB 是一个认知数据库（Cognitive Database，也称为"神经符号数据库"）的概念设计 —— 这是一个专为 LLM 设计的数据库，旨在作为大语言模型的外挂大脑/海马体。与传统数据库（SQL、NoSQL、文档、向量）不同，本数据库专注于记忆、推理和关联，而非简单的 CRUD 操作。

## 项目指南

- 目标：以强类型、可测试、分层解耦为核心，保证项目健壮性与可扩展性；以清晰可读、模式统一为核心，使大模型易于理解与改写。
- 语言约定：交流与文档使用中文；生成的代码使用英文；文档放在 `docs` 且使用 Markdown。
- 发布约定：
  - 发布固定在 `/release` 文件夹，如 rust 服务固定发布在 `/release/rust` 文件夹。
  - 发布的成果物必须且始终以生产环境为标准，要包含所有发布生产所应该包含的文件或数据（包含全量发布与增量发布，首次发布与非首次发布）。
- 环境约定：
  - 尽量使用docker部署环境
  - 尽量为项目配置独立的网络，避免与其他项目网络冲突
- 文档约定：
  - 每次修改都必须延续上一次的进展，每次修改的进展都必须保存在对应的 `docs` 文件夹下的文档中。
  - 执行修改过程中，进展随时保存文档，带上实际修改的时间，便于追溯修改历史。
  - 未完成的修改，文档保存在 `/docs/progress` 文件夹下。
  - 已完成的修改，文档保存在 `/docs/reports/completed` 文件夹下。
  - 对修改进行验收，文档保存在 `/docs/reports` 文件夹下。
  - 对重复的、冗余的、不能体现实际情况的文档或文档内容，要保持更新和调整。
  - 文档模板和命名规范可以参考 `/docs/standards` 和 `docs/templates` 文件夹下的内容。

### 面向大模型的可改写性（LLM Friendly）

- 一致的分层与目录：相同功能在各应用/包中遵循相同结构与命名，使检索与大范围重构更可控。
- 明确边界与单一职责：函数/类保持单一职责；公共模块暴露极少稳定接口；避免隐式全局状态。
- 显式类型与契约优先：导出 API 均有显式类型；运行时与编译时契约一致（zod schema 即类型源）。
- 声明式配置：将重要行为转为数据驱动（配置对象 + `as const`/`satisfies`），减少分支与条件散落。
- 可搜索性：统一命名（如 `parseXxx`、`assertNever`、`safeJsonParse`、`createXxxService`），降低 LLM 与人类的检索成本。
- 小步提交与计划：通过 `IMPLEMENTATION_PLAN.md` 和小步提交让模型理解上下文、意图与边界。
- 变更安全策略：批量程序性改动前先将原文件备份至 `/backup` 相对路径；若错误数异常上升，立即回滚备份。

### 记忆系统

本项目采用基于Markdown文件的透明双层记忆架构。禁止使用复杂的嵌入检索。 所有记忆操作必须对人类可读且对Git友好。

#### 存储结构

记忆分为两个独立的层："流"（日常）层和"沉积"（长期）层。

- 第一层：每日笔记（流）
  - 路径： `./memory/daily/{YYYY-MM-DD}.md`
  - 类型： 仅追加日志。
  - 目的： 记录上下文的"流动"。今天所说的一切、做出的决定以及完成的任务。
  - 格式： 按时间顺序排列的Markdown条目。

- 第二层：长期记忆（沉积）
  - 路径： `./memory/MEMORY.md`
  - 类型： 经过整理、结构化的知识。
  - 目的： 记录上下文的"沉积"。用户偏好、关键上下文、重要决策以及"经验教训"（避免过去的错误）。
  - 格式： 分类的Markdown（例如 `## 用户偏好`、`## 项目上下文`、`## 关键决策`）。

#### 操作规则

##### 上下文加载（读取）

当初始化会话或生成响应时，通过组合以下内容来构建系统提示：

1. 长期上下文： 读取 `MEMORY.md` 的全部内容。
2. 近期上下文： 读取当前（以及可选的之前）一天的每日笔记内容。

##### 记忆持久化（写入）

- 即时操作（日常）：
  - 将每一次重要的交互、工具输出或决策追加到当天的每日笔记中。
  - 不要覆盖或删除每日笔记中的内容；将其视为不可变的日志。
- 整合操作（长期）：
  - 触发条件： 当检测到有意义的信息时（例如，用户陈述了偏好、发现了特定的错误修复模式、建立了项目规则）。
  - 操作： 更新 `MEMORY.md`。
  - 方法： 智能地将新信息合并到现有类别中。如果信息已过时，则移除或更新它。此文件代表*当前*的真实状态。

#### 维护与调试

- 透明度： 所有记忆文件都是标准的Markdown文件。如果代理因错误的上下文而行为异常，修复方法是手动编辑 `.md` 文件。
- 版本控制： 所有记忆文件都受Git跟踪。

### 核心设计理念

数据库基于四大原则运作：

1. 入库即理解 - 自动知识图谱提取
2. 查询即推理 - 混合向量搜索 + 图遍历
3. 输出即上下文 - 为 LLM 提供预处理上下文，而非原始数据

### 提议架构 (CortexDB)

系统采用 4 层架构设计：

1. 接口层 (Interface Layer): PaQL (Prompt as Query Language) 解析器 - 接受自然语言查询而非 SQL
2. 认知计算层 (Cognitive Compute Layer): 使用嵌入式小语言模型 (SLM) 处理推理、重排序和上下文压缩
3. 张量图存储层 (Tensor-Graph Storage Layer): 核心引擎，将"语义单元"存储为节点（带向量）和边（带逻辑关系）
4. 基础设施层 (Infrastructure Layer): 基于 Rust，利用 mmap 和 NVMe 优化

### 核心数据模型：张量图 (Tensor-Graph)

节点 (语义原子):

- `ID`: UUID
- `Content`: 文本/图像数据
- `Embedding`: 向量表示（如 Float32[^1536]）
- `Meta`: 时间戳、来源、置信度分数、访问频率
- `Type`: 实体/概念/事实/原始片段

边 (逻辑链接):

- `SourceID` → `TargetID`
- `Relation`: 自然语言关系类型（如 "is_part_of"、"contradicts"、"happened_after"）
- `Weight`: 关联强度 (0.0-1.0)
- `Vector`: 关系向量表示，用于模糊关系查询

### 独有特性

1. Graph-RAG: 结合向量相似度搜索与多跳图遍历的混合检索
2. 自适应分块 (Adaptive Chunking): 语义感知的文档分割（非固定字符数）
3. 分层存储: 摘要层 → 段落层 → 句子层
4. 记忆衰退与强化: 基于遗忘曲线的数据管理，由访问分数驱动保留策略
5. 动态事实修正: 冲突检测与时序边版本管理（不覆盖数据）
6. 上下文合成: 数据库返回结构化上下文包，而非原始行数据

### 推荐技术栈（用于实现）

- 语言: Rust（内存安全、数据库内核性能）
- KV 存储: RocksDB 或 LMDB
- 向量索引: Faiss (C++ 绑定) 或 Lance (Rust 原生)
- 嵌入式 ML: ONNX Runtime 或 Candle (HuggingFace Rust ML 框架)
- 协议: gRPC (内部) + REST (外部)
